#!/usr/bin/env python
# -*- coding: utf-8 -*-

# keepconf - Backup and track files from hosts keeping them inside a repository
# Copyright (C) 2015 - Ricardo F.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

try:
    import sys, optparse, os, glob, time, string, re, tempfile, logging
    from configparser import ConfigParser
    from subprocess import call
    from distutils.util import strtobool
    from distutils.dir_util import mkpath
    from collections import OrderedDict
except Exception as e:
    sys.exit('ERROR modules not imported correctly: ' + str(e))

__version__ = '1.2.10'
__fconf__ = '/etc/keepconf/keepconf.cfg'  # default configuration file
VERBOSE=0

def get_arguments():
    """Get arguments from command line"""

    def print_version(*_):
        """Print version"""
        print('keepconf version ' + __version__)
        sys.exit(0)

    def enable_verbose(*_):
        """Enable verbose mode"""
        logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
        global VERBOSE
        VERBOSE=1

    parser = optparse.OptionParser()
    parser.add_option('-f', '--conf',
                      dest='conffile',
                      default=__fconf__,
                      action='store',
                      help='configuration file',
                      metavar="FILE")
    parser.add_option('-i', '--init',
                      dest='gitinit',
                      default=False,
                      action='store_true',
                      help='initialize git repostory')
    parser.add_option('-n', '--nocommit',
                      dest='commit',
                      default=True,
                      action='store_false',
                      help='avoid commit changes')
    parser.add_option('-c', '--commitonly',
                      dest='commitonly',
                      default=True,
                      action='store_false',
                      help='only commit changes')
    parser.add_option('-m', '--message',
                      dest='message',
                      default=False,
                      action='store',
                      help='commit message',
                      metavar="TEXT")
    parser.add_option('-s', '--silent',
                      dest='silent',
                      default=False,
                      action='store_true',
                      help='silent fetching output')
    parser.add_option('-x', '--xilent',
                      dest='xilent',
                      default=False,
                      action='store_true',
                      help='silent commit output')
    parser.add_option('-v', '--verbose',
                      action='callback',
                      callback=enable_verbose,
                      help='verbose output')
    parser.add_option('-V', '--version',
                      action='callback',
                      callback=print_version,
                      help='show version')
    options, _ = parser.parse_args()


    return options

def process_folder(str_folder, conf, dest):
    """Execute all files located in a external folder"""
    if not os.path.isdir(str_folder):
        logging.info(str_folder +' not exists')
        return
    print('- Finding files in ' + str_folder)
    folder_files = sorted(glob.glob(str_folder + '*'))  # get files in folder
    for b in folder_files:
        try:
            print('- Processing:', b)
            if not (os.path.isfile(b) and os.access(b, os.X_OK)):  # only execute executable files
                print('WARNING nothing done in non executable file ' + b)
            else:
                try:
                    sys.stdout.flush()
                    call([b, str(conf), str(dest)])  # call file with arguments
                    sys.stdout.flush()
                except Exception as e:
                    sys.exit('ERROR executing file: ' + str(e))
        except:
           logging.info('ERROR processing: ' + b +' '+ str(e))
    return


def yes_or_not(question):
    """Ask user for y/n"""
    sys.stdout.write('%s [y/n]\n' % question)
    while True:
        try:
            return strtobool(raw_input().lower())
        except ValueError:
            sys.stdout.write('Please respond with \'y\' or \'n\'.\n')

# The following two functions are written by Chin Fang <fangchin@zettar.com>
# and are part of Ansible software located in github.com/ansible
# Are distributed under the terms of GNU General Public License
# (c) 2012, Zettar Inc.

def detect_range(line=None):
    """Detect is line have a range"""
    if 0 <= line.find("[") < line.find("-") < line.find("]"):
        return True
    else:
        return False


def expand_range(line=None):
    """Expand name range"""
    all_hosts = []
    if line:
        (head, nrange, tail) = line.replace('[', '|', 1).replace(']', '|', 1).split('|')
        bounds = nrange.split("-")
        if len(bounds) != 2 and len(bounds) != 3:
            print("WARNING: Range incorrectly specified")
            raise
        beg = bounds[0]
        end = bounds[1]
        if len(bounds) == 2:
            step = 1
        else:
            step = bounds[2]
        if not beg:
            beg = "0"
        if not end:
            print("WARNING: Range end value missing")
            raise
        if beg[0] == '0' and len(beg) > 1:
            rlen = len(beg)  # range length formatting hint
            if rlen != len(end):
                print("WARNING: Range format incorrectly specified")
                raise
            fill = lambda _: str(_).zfill(rlen)  # range sequence
        else:
            fill = str

        try:
            i_beg = string.ascii_letters.index(beg)
            i_end = string.ascii_letters.index(end)
            if i_beg > i_end:
                print("WARNING: Range format invalid")
                raise
            seq = string.ascii_letters[i_beg:i_end+1]
        except ValueError:  # not an alpha range
            seq = range(int(beg), int(end)+1, int(step))

        for rseq in seq:
            hname = ''.join((head, fill(rseq), tail))
            if detect_range(hname):
                all_hosts.extend(expand_range(hname))
            else:
                all_hosts.append(hname)
        return all_hosts


def sanitize(text_value):
    """Remove especial characters"""
    excluded = "[\',\",\;,\,,\|,\<,\>]"  # excluded characters
    resultd = re.sub(excluded, '', ((text_value.split('#', 1)[0].split(';', 1)[0].split(',', 1)[0]).strip()))
    if resultd:
        return resultd
    else:
        logging.info('sanitize '+ text_value)
        raise


def call_out(call_, silent_=None, cwd_='/tmp'):
    """Execute external program and redirect stdout and stderr to null if is needed"""
    try:
        if silent_:
            return call(call_, cwd=cwd_, stdout=open(os.devnull, 'w'), stderr=open(os.devnull, 'w'))
        else:
            return call(call_, cwd=cwd_)
    except Exception as e:
        sys.exit('ERROR: executing external call '+ call_ +' '+ silent_ +' '+ cwd_ +' '+ e )


def extract_walk(cfg_in_, walking=True):
    """Deconstruct path, extract elements"""
    paths_lst = []
    for g in cfg_in_:  # for each line in the list of files/paths
        walk_lst = []
        if walking:
            head, _ = os.path.split(g)
            walk_path = ''
            for t in head.split('/'):  # extract, deconstruct, route path
                walk_path += t + '/'
                walk_lst.append(walk_path)
        # For a comprensive behaviour than rsync do alone, add an asterisk
        # to the paths that ends in a slash or slash and asterisk
        if g.endswith('/') or g.endswith('/*'):
            logging.info('Adding * to: ' + str(g))
            g += '*'
        walk_lst.append(g)  # add origin path after its deconstructed route
        paths_lst += walk_lst  # add processed path to the total amount
    return list(OrderedDict.fromkeys(paths_lst))


def test_repo_dir(d_dest_, commit_):
    """Test the state of the destination repo dir"""
    if not os.path.isdir(d_dest_+'.git') and commit_:
        sys.exit('ERROR: '+str(d_dest_)+' not have a repository\nPlease, try to initialize it with \"keepconf -i\"')


def git_init(c):
    if c['repo'] == 'local':  # local repo
        try:
            if os.path.isdir(os.path.join(c['d_dest'],'.git')):
                print('WARNING: A .git folder exists inside '+ c['d_dest'] +' directory!')
                if not yes_or_not('Do you want to initialize an exiting repository?'):
                    logging.info('Avoid initializating folder with .git directory')
                    sys.exit(0)
            sys.stdout.flush()
            call(('git', 'init', c['d_dest']))
            sys.stdout.flush()
        except Exception as e:
            sys.stdout.flush()
            sys.exit('ERROR local repository not initializated: '+ str(e))

    elif c['repo']:  # remote repo
        try:
            if os.path.isdir(c['d_dest']):
                if os.listdir(c['d_dest']) != []:
                    print('WARNING: Destination directory exists and is not empty!')
                    print('Please, fix '+c['d_dest'])
                    if not yes_or_not('Do you already did it, continue?'):
                        logging.info('Avoid clonning repository into destination folder: '+c['d_dest'])
                        sys.exit(0)
            else:
                logging.info('Creating directory'+ c['d_dest'])
                os.makedirs(c['d_dest'])
            print('Clonning repository...')
            sys.stdout.flush()
            call(('git', 'clone', c['repo'], c['d_dest']))
            sys.stdout.flush()
        except Exception as e:
            sys.stdout.flush()
            sys.exit('ERROR clonning remote repository: '+ str(e))
    else:
        sys.exit('ERROR initializating repository: ' + str(c['repo']))
    sys.exit(0)

#  Some test for avoid annoying errors
try:
    call_out('rsync', True)
except:
    sys.exit('ERROR rsync not execute correctly in test. Maybe not installed')

try:
    call_out('git', True)
except:
    sys.exit('ERROR git not execute correctly in test. Maybe not installed')


def main():
        # Inside this function:
        # - Read command line options
        # - Parse verbose option
        # - Parse version option
        # - Get and parse configuration file
        # - Get f_monitor
        # - Get fetch and commit
        # - Get repo, max_size, rsync_user and rsync_opt
        # - Get pre_get, post_get, pre_commit, post_commit
        # - Get d_dest and d_conf
        # - Parse init option
        # - Parse fetch (no commit) option
        # - Parse commit option
        # - Print stats
        # - Write csv report file

        start_time = time.time()

        hosts_ok, hosts_bad = [], []
        d_roles = 'roles/'  # default roles directory inside 'd_conf'

        c = {
        'd_conf': False,
        'd_dest': False,
        'f_monitor': False,
        'fetch': True,
        'pre_get': False,
        'post_get': False,
        'max_size': '25M',
        'rsync_user': 'backup',
        'rsync_timeout': '5',
        'rsync_opt': 'arHvzL',
        'commit': True,
        'pre_commit': False,
        'post_commit': False,
        'repo': 'local'}

        options = get_arguments()

        # - Get and parse configuration file
        logging.info('Reading configuration file: '+ options.conffile)
        try:
            if not (os.path.isfile(options.conffile)):
                raise ValueError('Invalid configuration file')
            else:
                parser = ConfigParser()
                parser.read(options.conffile)
        except ValueError as e:
            sys.exit('ERROR reading configuration file: '+ str(options.conffile) +' '+  str(e))

        def assign_variable(c, section, key, normpath=False):
            try:
                if normpath:
                    value = os.path.normpath(sanitize(parser.get(section, key)))+os.sep
                else:
                    value = sanitize(parser.get(section, key))
                if value.lower() in ('false', '0', 'not'):
                    value = False
            except:
                value = c[key]
            logging.info('['+section +'] '+ key +': '+ str(value))
            return value

        # - Get key values
        c['d_conf'] = assign_variable(c, 'main', 'd_conf')
        c['d_dest'] = assign_variable(c, 'main', 'd_dest')
        c['f_monitor'] = assign_variable(c, 'main', 'f_monitor')
        if options.commitonly:
            c['fetch'] = assign_variable(c, 'sync', 'fetch')
        else:
            c['fetch'] = False
        c['pre_get'] = assign_variable(c, 'sync', 'pre_get', normpath=True)
        c['post_get'] = assign_variable(c, 'sync', 'post_get', normpath=True)
        c['max_size'] = assign_variable(c, 'sync', 'max_size')
        c['rsync_user'] = assign_variable(c, 'sync', 'rsync_user')
        c['rsync_opt'] = assign_variable(c, 'sync', 'rsync_opt')
        if options.commit:
            c['commit'] = assign_variable(c, 'vcs', 'commit')
        else:
            c['commit'] = False
        c['pre_commit'] = assign_variable(c, 'vcs', 'pre_commit', normpath=True)
        c['post_commit'] = assign_variable(c, 'vcs', 'post_commit', normpath=True)
        c['repo'] = assign_variable(c, 'vcs', 'repo')

        # Check variable requirements
        if (not options.gitinit and c['commit']) and not os.path.isdir(str(c['d_dest'])):
            sys.exit('ERROR: '+ str(c['d_dest']) +' is not a valid \"d_conf\" directory or is not initialized.\nPlease, try to execute \"keepconf -i\"')
        if not os.path.isdir(str(c['d_conf'])):
            sys.exit('ERROR: '+ str(c['d_conf']) +' is not a valid \"d_conf\" directory')

        # - Parse init option
        if options.gitinit:
            git_init(c)

        # - Parse fetch (no commit) option
        if c['fetch']:
            # Inside this if:
            # + Execute pre-get.d
            # + Parse cfg files
            # + Parse roles section
            # + Get roles file lines
            # + Parse hosts section, get list of hosts
            # + Parse roles files
            # + Get directory variable
            # + Get rsync_user and max_size variables
            # + Parse files section, get includes/excludes/forced paths
            # + Write to include/exclude rsync file
            # + Create destination directories
            # + Fetching content
            # + Execute post-get.d

            fetch_time = time.time()
            test_repo_dir(c['d_dest'], c['commit'])
            print('- Fetching start')

            # + Execute pre-get.d
            if c['pre_get']:
                process_folder(c['pre_get'], c['d_conf'], c['d_dest'])

            srvfiles = sorted(glob.glob(os.path.join(c['d_conf'],'*.cfg')))  # get files in d_conf dir

            # + Parse cfg files
            for i in srvfiles:
                print('- Processing:', i)

                p = {
                'directory': None,
                'max_size': c['max_size'],
                'rsync_user': c['rsync_user'],
                'roles_files': [],
                'host_list': [],
                'cfg_in': [],
                'cfg_ex': [],
                'cfg_frz': []}

                try:   # temporary file for include/exclude to rsync
                    _, f_tmp_walk = tempfile.mkstemp()
                    f_walk = open(f_tmp_walk, 'w')
                except:
                    sys.exit('ERROR creating temporary file')

                logging.info('Reading host config file:'+ i)
                try:
                    parser = ConfigParser(allow_no_value=True)
                    parser.read(i)
                except:
                    sys.exit('ERROR reading host config file: '+ str(i))

                # + Parse roles section
                try:
                    for line, _ in parser.items('roles'):
                        line = (sanitize(line))
                        logging.info('Role: ' + line)
                        p['roles_files'].append(line)

                    # + Get roles file lines - Process
                    if p['roles_files'][0]:
                        def get_roles_files(p):
                            for s in p['roles_files'][:]:  # go over each role
                                p['roles_files'].remove(s)  # remove before process
                                s = sanitize(s)
                                p['roles_files'].append(os.path.join(c['d_conf'] + d_roles, s))

                            for t in p['roles_files'][:]:  # parse paths for checking the name integrity
                                p['roles_files'].remove(t)
                                role_glob = glob.glob(t)
                                if not role_glob:
                                    logging.info('WARNING, excluding invalid role file: ' + str(t)) 
                                else:
                                    p['roles_files'].extend(role_glob)
                            p['roles_files'].insert(0, sanitize(i))  # insert own file at first position
                            p['roles_files'] = p['roles_files'][::-1]  # reverse order for hieracally process

                        p['roles_files'] = get_roles_files(p)
                        print('- Roles:', ', '.join(p['roles_files']))
                    else:
                        raise Exception('WARNING in roles section')
                except Exception as e:
                    p['roles_files'] = []
                    p['roles_files'].insert(0, sanitize(i))  # insert parent cfg file at first position
                    logging.info('WARNING parsing roles section ' + str(e))
                logging.info('roles value:'+ str(p['roles_files']))

                # + Parse hosts section, get list of hosts
                try:
                    for line, _ in (parser.items('hosts')):
                        p['host_list'].append(sanitize(line))
                        logging.info('Reading hosts:'+ line)

                    if p['host_list'][0]:  # if empty host list skip the file
                        logging.info('Hosts value:'+ str(p['host_list']))
                        for re_hosts in p['host_list']:  # parse expand option if match
                            if detect_range(re_hosts):
                                logging.info('Range detected: '+ str(re_hosts))
                                p['host_list'] = p['host_list'] + expand_range(re_hosts)  # expand hostnames
                                p['host_list'].remove(re_hosts)  # remove range from list
                        p['host_list'] = sorted(set(p['host_list']))  # remove duplicate names and order
                        logging.info('Lists of hosts: '+ str(p['host_list']))
                    else:
                        raise Exception('Empty Hosts')
                except Exception as e:
                    print('WARNING Almost, one host must be defined')
                    print('WARNING Skipping file', i)
                    continue

                # + Parse roles files
                for j in p['roles_files']:
                    logging.info('- Processing:'+ j)
                    if not os.path.isfile(j):
                        logging.info('Invalid file:', j)
                        continue

                    try:  # read cfg file
                        parser = ConfigParser(allow_no_value=True)
                        parser.read(j)
                    except Exception as e:
                        sys.exit('ERROR reading cfg file: '+j+' '+ str(e))

                    # + Get directory variable
                    try:
                        p['directory'] = os.path.normpath(sanitize(parser.get('main', 'directory')))+os.sep
                        logging.info('directory:'+ str(p['directory'],))
                    except:
                        if p['directory'] == None:
                            logging.info('directory empty')
                        else:
                            logging.info('directory heritage: ' + str(p['directory']))

                    # + Get rsync_user and max_size variables
                    for val in ('rsync_user','max_size'):
                        try:
                            p[val] = sanitize(parser.get('main', val))
                            logging.info(val+ ': '+ str(p[val]))
                        except:
                            logging.info(val +' herietage: '+ str(p[val]))

                    # + Parse files section, get includes/excludes/forced paths
                    try:
                        if parser.items('files') != []:
                            for line, _ in parser.items('files'):
                                line_range = []
                                line = (sanitize(line))
                                if detect_range(line):  # detect range inside
                                    logging.info('Range detected: ', line)
                                    line_range = expand_range(line)
                                else:
                                    line_range.append(line)
                                for lpath in line_range:  # detect each type of line
                                    if lpath.startswith('!'):
                                        logging.info('Exclude: '+ lpath[1:].rstrip())
                                        p['cfg_ex'].append(lpath[1:])
                                    elif lpath.startswith('&'):
                                        logging.info('Force Incl: ', lpath[1:].rstrip())
                                        p['cfg_frz'].append(lpath[1:])
                                    else:
                                        logging.info('Include: '+ lpath.rstrip())
                                        p['cfg_in'].append(lpath)
                        else:
                            logging.info('WARNING empty file list')
                    except Exception as e:
                        logging.info('WARNING parsing files section in: ' + j + ' ' + str(e))

                # + Write to include/exclude rsync file
                for val in ('cfg_in', 'cfg_ex', 'cfg_frz'):
                    try:
                        p[val]=sorted(set(p[val]))  # clean duplicates and order
                    except Exception as e:
                        logging.info('WARNING sorting: ' + val + ' ' + str(e))

                if p['cfg_frz']:
                    paths_lst_frz = extract_walk(p['cfg_frz'])
                    logging.info('Force paths: '+str(p['cfg_frz'])+'->'+str(paths_lst_frz))
                    for e in paths_lst_frz:
                        f_walk.write('+ ' + e + '\n')

                if p['cfg_ex']:
                    paths_lst_ex = extract_walk(p['cfg_ex'], False)
                    logging.info('Exclude paths: '+str(p['cfg_ex'])+'->'+str(paths_lst_ex))
                    for e in paths_lst_ex:
                        f_walk.write('- ' + e + '\n')

                if p['cfg_in']:
                    paths_lst_in = extract_walk(p['cfg_in'])
                    logging.info('Include paths: '+str(p['cfg_in'])+'->'+str(paths_lst_in))
                    for e in paths_lst_in:
                        f_walk.write('+ ' + e + '\n')

                f_walk.write('- *\n')  # this line must be always in the file
                f_walk.seek(0)

                # + Create destination directories
                for srvname in p['host_list']:
                    try:
                        final_path = os.path.join(c['d_dest'], p['directory'], srvname)
                    except:
                        final_path = os.path.join(c['d_dest'], srvname)

                    if not os.path.isdir(final_path):  # if local folder not exists, do it
                        try:
                            logging.info('Making directory', final_path)
                            mkpath(final_path)
                        except Exception as e:
                            sys.exit('ERROR creating destination server directory: '+final_path+' - '+str(e))

                    # + Fetching content
                    print('- Fetching:', srvname)
                    # ssh options for avoid annoying errors in rsync, if you need security, please remove from
                    # the rsync_call "'-e', ssh_rsync_opt,"
                    if VERBOSE:
                        ssh_rsync_opt='ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null'
                    else:
                        ssh_rsync_opt='ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=quiet'
                    # syncing files, for modify rsync call, the place is the following line:
                    rsync_call = ('rsync', '-e', ssh_rsync_opt, '-'+c['rsync_opt'], '--progress', '--delete-excluded', 
                    '--timeout='+c['rsync_timeout'], '--ignore-errors', '--max-size='+p['max_size'], 
                    '--include-from=' + f_walk.name, '--prune-empty-dirs', p['rsync_user']+'@'+srvname+':/', final_path)
                    logging.info(' '.join(map(str,rsync_call)))
                    try:
                        sys.stdout.flush()
                        if (call_out(rsync_call, options.silent, c['d_dest'])) == 0:
                            hosts_ok.append(srvname)
                        else:
                            hosts_bad.append(srvname)
                        sys.stdout.flush()

                    except Exception as e:
                        sys.stdout.flush()
                        sys.exit('ERROR executing rsync command: ' + str(e))

                f_walk.close()

                if VERBOSE:
                    logging.info('WARNING temporary files not deleted in verbose mode')
                else:
                    os.remove(f_tmp_walk)

            # + Execute post-get.d
            if c['post_get']:
                process_folder(c['post_get'], c['d_conf'], c['d_dest'])

            time_fetched = time.time() - fetch_time
            print('- Fetching done')
        else:
            logging.info('Avoid fetching files')

        # + Parse commit option
        if c['commit'] and c['repo']:

            commit_time = time.time()
            test_repo_dir(c['d_dest'], c['commit'])
            print('- Committing start')

            # Execute pre-commit.d
            if c['pre_commit']:
                process_folder(c['pre_commit'], c['d_conf'], c['d_dest'])

            # Parse message option
            if options.message:
                message = 'Keepconf: ' + options.message
            else:
                message = 'Keepconf commit at '+time.strftime('%H:%M:%S - %A/%B/%Y')
                if hosts_ok or hosts_bad:
                    message += '\nHosts ok: '+'['+ str(len(hosts_ok))+'] ' + ', '.join(hosts_ok)
                    message += '\nHosts bad: '+'['+ str(len(hosts_bad))+'] ' + ', '.join(hosts_bad)

            # Commit into local or remote repository
            if c['repo'] == 'local':
                print('- Committing into local repository')
                try:
                    sys.stdout.flush()
                    call_out(('git', 'add', c['d_dest']+'*'), options.xilent, c['d_dest'])
                    call_out(('git', 'commit', '-am', message), options.xilent, c['d_dest'])
                except Exception as e:
                    sys.stdout.flush()
                    sys.exit('ERROR committing into local repository: ' + str(e))
            else:
                # print '- Updating remote repository' # for avoid problems
                # call_out(('git', 'pull'), options.xilent, cwd=c['d_dest'])
                print('- Committing into remote repository')
                try:
                    sys.stdout.flush()
                    call_out(('git', 'add', '--all'), options.xilent, c['d_dest'])
                    call_out(('git', 'commit', '-am', message), options.xilent, c['d_dest'])
                    call_out(('git', 'push'), options.xilent, c['d_dest'])
                except Exception as e:
                    sys.stdout.flush()
                    sys.exit('ERROR committing into remote repository: ' + str(e))
            sys.stdout.flush()

            # Execute post-commit.d
            if c['post_commit']:
                process_folder(c['post_commit'], c['d_conf'], c['d_dest'])

            time_committed = time.time() - commit_time
            print('- Committing done')
        else:
            logging.info('Avoid committing changes')

        # + Print stats
        if c['fetch'] or (c['commit'] and c['repo']):
            print('- ')

        if c['fetch']:
            print('- Hosts rsync\'ed: ' +'['+ str(len(hosts_ok)) +'] '+ ', '.join(hosts_ok))
            print('- Hosts not rsync\'ed: ' +'['+ str(len(hosts_bad)) +'] '+ ', '.join(hosts_bad))
            print('- Fetched in: %.2f seconds' % time_fetched)
        if c['commit'] and c['repo']:
            print('- Committed in: %.2f seconds' % time_committed)

        total_time = time.time() - start_time
        if c['fetch'] or c['commit']:
            print('- Completed in: %.2f seconds' % total_time)

        # + Write csv report file
        if c['f_monitor']:

            logging.info('Writing stats to monitor file '+ str(c['f_monitor']))
            try:
                with open(c['f_monitor'], "w"):  # clean monitor file
                    pass
                if hosts_bad:
                    hosts_bad_list = ","+ ','.join(['\"'+ x +'\"' for x in hosts_bad])
                else:
                    hosts_bad_list = ''
                if hosts_ok:
                    hosts_ok_list = "," +','.join(['\"'+ x +'\"' for x in hosts_ok])
                else:
                    hosts_ok_list = ''
                with open(c['f_monitor'], "a") as file_monitor:
                    try:
                        file_monitor.write('\"CFG-FILE\",\"' + os.path.basename(options.conffile)+'\"\n')
                    except:
                        file_monitor.write('\"BadCfgFileName\"\n')
                    try:
                        file_monitor.write('\"OK\",\"' + str(len(hosts_ok)) + '\"' + hosts_ok_list + '\n')
                    except:
                        file_monitor.write('\"OK\",\"0\"\n')
                    try:
                        file_monitor.write('\"BAD\",\"' + str(len(hosts_bad)) + '\"' + hosts_bad_list + '\n')
                    except:
                        file_monitor.write('\"BAD\",\"0\"\n')
                    try:
                        file_monitor.write('\"FETCH-T\",\"%.2f' % time_fetched + '\"\n')
                    except:
                        file_monitor.write('\"FETCH-T\",\"0\"\n')
                    try:
                        file_monitor.write('\"COMMIT-T\",\"%.2f' % time_committed + '\"\n')
                    except:
                        file_monitor.write('\"COMMIT-T\",\"0\"\n')
                    file_monitor.write('\"TOTAL-T\",\"%.2f' % total_time + '\"\n')
            except Exception as e:
                sys.exit('ERROR writing into monitor file: ' + str(e))

if __name__ == "__main__":
    main()
