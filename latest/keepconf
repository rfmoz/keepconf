#!/usr/bin/env python
# -*- coding: utf-8 -*-

# keepconf - Backup and tracking files from other hosts into a git repository.
# Copyright (C) 2015 - Ricardo F.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

try:
    import sys, optparse, os, glob, time, time, string, re, tempfile
    from ConfigParser import ConfigParser
    from subprocess import call
    from distutils.util import strtobool
    from distutils.dir_util import mkpath
    from collections import OrderedDict
except Exception as e:
    sys.exit('ERROR modules not imported correctly: ' + str(e))

start_time = time.time()

version = '0.9.31'
f_conf = '/etc/keepconf/keepconf.cfg'  # Default configuration file
f_max_size = '25M'  # Default max size rsync value
f_rsync_user = "root"  # Default rsync user
rsync_opt = 'arHvz'  # Default options for rsync
rsync_timeout = '5'  # Default rsync timeout
hosts_ok, hosts_bad, hosts_not_mon, cfg_hosts = [], [], [], []


def process_folder(str_folder):  # Process external folders
    if not os.path.isdir(str_folder):
        vprint('WARNING '+ str_folder +' not exists')
        return
    print "- Finding files in " + str_folder
    folder_files = glob.glob(str_folder + '*')  # Get files in folder
    for b in folder_files:
        print "- Processing:", b
        if not (os.path.isfile(b) and os.access(b, os.X_OK)):  # Test if is executable each file
            print "WARNING nothing done in non executable file " + b
        else:
            try:
                sys.stdout.flush()
                call([b, str(d_conf), str(d_dest)])  # Call file with arguments
                sys.stdout.flush()
            except Exception as e:
                sys.exit('ERROR executing file: ' + str(e))
    return


def yes_or_not(question):  # Ask user for y/n
    sys.stdout.write('%s [y/n]\n' % question)
    while True:
        try:
            return strtobool(raw_input().lower())
        except ValueError:
            sys.stdout.write('Please respond with \'y\' or \'n\'.\n')


def detect_range(line=None):
    if 0 <= line.find("(") < line.find("-") < line.find(")"):
        return True
    else:
        return False


def expand_hostname_range(line=None):
    all_hosts = []
    if line:
        (head, nrange, tail) = line.replace('(', '|', 1).replace(')', '|', 1).split('|')
        bounds = nrange.split("-")
        if len(bounds) != 2 and len(bounds) != 3:
            print "host range incorrectly specified"
            raise
        beg = bounds[0]
        end = bounds[1]
        if len(bounds) == 2:
            step = 1
        else:
            step = bounds[2]
        if not beg:
            beg = "0"
        if not end:
            print "host range end value missing"
            raise
        if beg[0] == '0' and len(beg) > 1:
            rlen = len(beg)  # range length formatting hint
            if rlen != len(end):
                print "host range format incorrectly specified!"
                raise
            fill = lambda _: str(_).zfill(rlen)  # range sequence
        else:
            fill = str

        try:
            i_beg = string.ascii_letters.index(beg)
            i_end = string.ascii_letters.index(end)
            if i_beg > i_end:
                print "host range format incorrectly specified!"
                raise
            seq = string.ascii_letters[i_beg:i_end+1]
        except ValueError:  # not an alpha range
            seq = range(int(beg), int(end)+1, int(step))

        for rseq in seq:
            hname = ''.join((head, fill(rseq), tail))
            if detect_range(hname):
                all_hosts.extend(expand_hostname_range(hname))
            else:
                all_hosts.append(hname)
        return all_hosts


def sanitize(text_value):  # Remove especial characters
    excluded = "[\&,\',\",\;,\,,\|,\<,\>]"
    resultd = re.sub(excluded, '', (string.strip(text_value.split('#', 1)[0].split(';', 1)[0].split(',', 1)[0])))
    if resultd:
        return resultd
    else:
        raise


def call_silent(call_, cwd_):
    return call(call_, cwd=cwd_, stdout=open(os.devnull, 'w'), stderr=open(os.devnull, 'w'))


def extract_walk(cfg_in_):
    paths_lst = []
    # For each line in the files lists
    for g in cfg_in_:
        head, _ = os.path.split(g)
        walk_path = ''
        walk_lst = []
        # Expand the walk for each directory
        for t in head.split('/'):
            walk_path += t + '/'
            walk_lst.append(walk_path)
        if g.endswith('/') or g.endswith('/*'):
            vprint('Adding * to: ' + str(g)) # For a comprensive behaviour
            g += '*'
        walk_lst.append(g)
        paths_lst += walk_lst
    return list(OrderedDict.fromkeys(paths_lst))


# Some basic test for avoid annoying errors
try:
    pyversion = sys.version.split(' ')[0][:3]
    if pyversion < '2.7':
        sys.exit('ERROR phyton 2.7 or greather needed.')
except:
    sys.exit('ERROR testing python version')

try:
    if call_silent(('rsync', '--version'), '/tmp/'):
        vprint('Rsync exists')
except:
    sys.exit('ERROR rsync not execute correctly in test. Maybe not installed')

try:
    if call_silent(('git', '--version'), '/tmp/'):
        vprint('Git exists')
except:
    sys.exit('ERROR git not execute correctly in test. Maybe not installed')

parser = optparse.OptionParser()  # Parse options
parser.add_option('-f', '--conf',
                  dest='conf',
                  default=f_conf,
                  action='store',
                  help='configuration file',
                  metavar="FILE",
                  )
parser.add_option('-i', '--init',
                  dest='gitinit',
                  default=False,
                  action='store_true',
                  help='initialize git repostory',
                  )
parser.add_option('-n', '--nocommit',
                  dest='commit',
                  default=True,
                  action='store_false',
                  help='avoid commit changes',
                  )
parser.add_option('-c', '--commitonly',
                  dest='commitonly',
                  default=True,
                  action='store_false',
                  help='only commit changes',
                  )
parser.add_option('-m', '--message',
                  dest='message',
                  default=False,
                  action='store',
                  help='commit message',
                  metavar="TEXT",
                  )
parser.add_option('-s', '--silent',
                  dest='silent',
                  default=False,
                  action='store_true',
                  help='silent fetching output',
                  )
parser.add_option('-x', '--xilent',
                  dest='xilent',
                  default=False,
                  action='store_true',
                  help='silent commit output',
                  )
parser.add_option('-v', '--verbose',
                  dest='verbose',
                  default=False,
                  action='store_true',
                  help='verbose output',
                  )
parser.add_option('-V', '--version',
                  dest='version',
                  default=False,
                  action='store_true',
                  help='show version',
                  )
options, _ = parser.parse_args()

if options.verbose:  # Parse verbose
    def vprint(*args):
        for arg in args:
            print arg,
        print
else:  # Do nothing
    vprint = lambda *a: None

if options.version:  # Parse version
    print 'keepconf version', version
    sys.exit(0)

vprint('Reading configuration file:', options.conf)
try:  # Read config file
    if not (os.path.isfile(options.conf)):  # Test if is file exists
        raise Exception
    else:
        parser = ConfigParser()
        parser.read(options.conf)
except Exception as e:
    sys.exit('ERROR reading configuration file: '+ str(options.conf) +' '+  str(e))

try:  # Getting D_Conf variable
    d_conf = os.path.normpath(sanitize(parser.get('Main', 'D_Conf')))+os.sep
    vprint('D_Conf value:', d_conf)
    if not os.path.isdir(d_conf):
        sys.exit('ERROR: '+ str(d_conf) +' is not a valid D_Conf directory')
except Exception as e:
    sys.exit('ERROR D_Conf variable not defined: '+ str(e))

try:  # Getting D_Dest variable
    d_dest = os.path.normpath(sanitize(parser.get('Main', 'D_Dest')))+os.sep
    vprint('D_Dest value:', d_dest)
    if not options.gitinit:
        if not os.path.isdir(d_dest):
            sys.exit('ERROR '+ str(d_dest) +' is not a valid D_Dest directory\nMaybe you need to create it before and initialize with \"keepconf -i\"')
except Exception as e:
    sys.exit('ERROR D_Dest variable not defined: '+ str(e))

try:  # Getting Pre_Get variable
    d_pre_get = os.path.normpath(sanitize(parser.get('Sync', 'Pre_Get')))+os.sep
    vprint('Pre_Get value:', d_pre_get)
except:
    d_pre_get = False
    vprint('Pre_Get not used')

try:  # Getting Post_Get variable
    d_post_get = os.path.normpath(sanitize(parser.get('Sync', 'Post_Get')))+os.sep
    vprint('Post_Get value:', d_post_get)
except:
    d_post_get = False
    vprint('Post_Get not used')

try:  # Getting Pre_Commit variable
    d_pre_commit = os.path.normpath(sanitize(parser.get('VCS', 'Pre_Commit')))+os.sep
    vprint('Pre_Commit value:', d_pre_commit)
except:
    d_pre_commit = False
    vprint('Pre_Commit not used')

try:  # Getting Post_Commit variable
    d_post_commit = os.path.normpath(sanitize(parser.get('VCS', 'Post_Commit')))+os.sep
    vprint('Post_Commit value:', d_post_commit)
except:
    d_post_commit = False
    vprint('Post_Commit not used')

try:  # Getting Repo variable
    repo_name = sanitize(parser.get('VCS', 'Repo'))
    if repo_name.lower() in ('false', '0', 'not'):
        repo_name = False
    vprint('Repo value:', repo_name)
except:
    repo_name = False
    vprint('Repo variable not defined')

try:  # Getting Max_Size
    f_max_size = sanitize(parser.get('Sync', 'Max_Size'))
    vprint('Max_Size value:', f_max_size)
except:
    vprint('Max_Size value get default limit:', f_max_size)

try:  # Getting Rsync_User user
    f_rsync_user = sanitize(parser.get('Sync', 'Rsync_User'))
    vprint('Rsync_User value:', f_rsync_user)
except Exception as e:
    vprint('Rsync_User value get default:', f_rsync_user)

try:  # Getting Rsync_Opt options
    rsync_opt = sanitize(parser.get('Sync', 'Rsync_Opt'))
    vprint('Rsync_Opt value:', rsync_opt)
except Exception as e:
    vprint('Rsync_Opt value get default:', rsync_opt)

try:  # Getting Commit variable
    if options.commit:
        commit = sanitize(parser.get('VCS', 'Commit'))
        if commit.lower() in ('false', '0', 'not'):
            commit = False
        else:
            raise
    else:
        raise
    vprint('Commit value:', commit)
except:
    commit = options.commit
    vprint('Commit value get default value:', commit)

try:  # Getting Fetch variable
    if options.commitonly:
        fetch = sanitize(parser.get('Sync', 'Fetch'))
        if fetch.lower() in ('false', '0', 'not'):
            fetch = False
        else:
            raise
    else:
        raise
    vprint('Fetch value:', fetch)
except:
    fetch = options.commitonly
    vprint('Fetch value get default value:', fetch)

try:  # Getting Monitor file variable
    f_monitor = os.path.normpath(sanitize(parser.get('Main', 'Monitor_File')))
    if f_monitor.lower() in ('false', '0', 'not'):
        f_monitor = False
    else:  # Clean monitor file
        with open(f_monitor, "w"):
            pass
    vprint('Monitor_File value:', f_monitor)
except:
    f_monitor = False
    vprint('Monitor_File value get default value:', f_monitor)

try:  # Getting Monitor Hosts variable
    f_host_mon = sanitize(parser.get('Main', 'Monitor_Hosts'))
    if f_host_mon.lower() in ('false', '0', 'not'):
        f_host_mon = False
    else:
        raise
    vprint('Monitor_Hosts value:', f_host_mon)
except:
    f_host_mon = True
    vprint('Monitor_Hosts value get value:', f_host_mon)

if options.gitinit:  # Parse initialize option
    if repo_name == 'local':
        try:
            if os.path.isdir(d_dest+'.git') and repo_name:
                print 'WARNING: A .git folder exists inside '+ d_dest +' directory!'
                if not yes_or_not('Do you want to initialize an exiting repository?'):
                    vprint('Avoid initializating folder with .git directory')
                    sys.exit(0)
            sys.stdout.flush()
            call(('git', 'init', d_dest))
            sys.stdout.flush()
        except Exception as e:
            sys.exit('ERROR local repository not initializated: '+ str(e))
    elif repo_name:
        try:
            if os.path.isdir(d_dest):
                print 'WARNING: Destination directory exists and is not empty!'
                print 'Please, delete '+d_dest+' before initialize the repo into it'
                if not yes_or_not('Do you want to continue?'):
                    vprint('Avoid clonning repository into destination folder: '+d_dest)
                    sys.exit(0)
            print 'Clonning repository...'
            sys.stdout.flush()
            call(('git', 'clone', repo_name, d_dest))
            sys.stdout.flush()
        except Exception as e:
            sys.exit('ERROR clonning remote repository: '+ str(e))
    else:
        sys.exit('ERROR initializating repository: ' + str(repo_name))
    sys.exit(0)

if fetch:
    fetch_time = time.time()
    print '- Fetching start'
    if d_pre_get:
        process_folder(d_pre_get)  # Execute post-get.d

    srvfiles = glob.glob(d_conf+'*.cfg')  # Get files in conf dir folder

    for i in srvfiles:  # Process each file
        print '- Processing:', i

        # Reset variables for each new cfg file
        rsync_user = f_rsync_user
        max_size = f_max_size
        host_mon = f_host_mon
        cfg_directory = ''
        cfg_includes, cfg_hosts, cfg_in, cfg_ex, cfg_frz = [], [], [], [], []

        try:   # Temporary files for include/exclude  to rsync
            _, f_tmp_walk = tempfile.mkstemp()
            f_walk = open(f_tmp_walk, 'w')

        except Exception as e:
            sys.exit('ERROR creating temporary file: ' + str(e))

        vprint('Reading configuration file:', i)
        try:
            parser = ConfigParser(allow_no_value=True)
            parser.read(i)
        except Exception as e:
            sys.exit('ERROR reading configuration file: '+ str(e))

        try:   # Get INCLUDES variable
            cfg_includes = parser.get('Main', 'Includes').strip(',$').split(',')
            if cfg_includes[0]:
                cfg_includes = [d_conf + sanitize(s) for s in cfg_includes]  # Add path to each file
                cfg_includes.insert(0, sanitize(i))  # Insert own file at the first position
                cfg_includes = cfg_includes[::-1]  # Reverse order for hieracally process
            else:
                raise Exception('Empty Includes')
        except:
            cfg_includes = []
            cfg_includes.insert(0, sanitize(i))  # Insert this file at the first position
        vprint('Includes value:', cfg_includes)

        try:  # Reading hosts list
            for line, _ in (parser.items('Hosts')):
                cfg_hosts.append(sanitize(line))
                vprint('Reading hosts:', line)
            if cfg_hosts[0]:
                vprint('Hosts value:', cfg_hosts)
            else:
                raise Exception('Empty Hosts')
        except Exception as e:
            print 'WARNING Almost, one host must be defined'
            print 'WARNING Skipping file', i
            continue

        for re_hosts in cfg_hosts:  # Parse expand option if match
            if detect_range(re_hosts):
                vprint('Range detected: ', re_hosts)
                cfg_hosts = cfg_hosts + expand_hostname_range(re_hosts)  # Expand hostnames
                cfg_hosts.remove(re_hosts)  # Remove range from list

        cfg_hosts = sorted(set(cfg_hosts))  # Remove duplicate names and order
        vprint('Lists of hosts: ', cfg_hosts)

        for j in cfg_includes:  # Process include files
            vprint('- Processing:', j)
            if not os.path.isfile(j):
                vprint('Invalid file:', j)
                continue

            try:  # Read file
                parser = ConfigParser(allow_no_value=True)
                parser.read(j)
            except Exception as e:
                sys.exit('ERROR reading cfg file: '+j+' '+ str(e))

            try:  # Parse Directory
                cfg_directory = os.path.normpath(sanitize(parser.get('Main', 'Directory')))+os.sep
                vprint('Directory:', cfg_directory,)
            except:
                if cfg_directory == '':
                    vprint('Directory empty')
                else:
                    vprint('Directory heritage: ' + cfg_directory)

            try:  # Parse Monitor
                host_mon = sanitize(parser.get('Main', 'Monitor'))
                if host_mon.lower() in ('false', '0', 'not', ''):
                    host_mon = False
                else:
                    host_mon = True
                vprint('Monitor: ', host_mon,)
            except:
                vprint('Monitor herietage: ', host_mon,)

            try:  # Parse Rsync_User
                rsync_user = sanitize(parser.get('Main', 'Rsync_User'))
                vprint('Rsync_User: ', rsync_user,)
            except:
                vprint('Rsync_User herietage: ', rsync_user,)

            try:  # Parse Max_Size
                max_size = sanitize(parser.get('Main', 'Max_Size'))
                vprint('Max_Size: ', max_size)
            except:
                vprint('Max_Size herietage: ', max_size)

            line_range = []
            try:  # Parse includes/excludes
                for line, _ in parser.items('Files'):
                    line = (sanitize(line))
                    if detect_range(line):  # Detect range inside
                        vprint('Range detected: ', line)
                        line_range = expand_hostname_range(line)  # Expand hostnames
                    else:
                        line_range.append(line)
                    for lpath in line_range:  # Detect each type of line
                        if lpath.startswith('!'):
                            vprint('Exclude: ', lpath[1:].rstrip())
                            cfg_ex.append(lpath[1:])
                        elif lpath.startswith('$'):
                            vprint('Force: ', lpath[1:].rstrip())
                            cfg_frz.append(lpath[1:])
                        else:
                            vprint('Include: ', lpath.rstrip())
                            cfg_in.append(lpath)
            except Exception as e:
                vprint('WARNING parsing Files section in: ' + j + ' ' + str(e))

	cfg_in=sorted(set(cfg_in))  # Clean duplicates and order
	cfg_ex=sorted(set(cfg_ex))
	cfg_frz=sorted(set(cfg_frz))

        paths_lst_in = extract_walk(cfg_in)
        vprint('Include walk for: '+str(cfg_in)+str(paths_lst_in))

        vprint('Exclude paths for: '+str(cfg_ex))

        paths_lst_frz = extract_walk(cfg_frz)
        vprint('Force walk for: '+str(cfg_frz)+str(paths_lst_frz))

        for e in paths_lst_frz:
            f_walk.write('+ ' + e + '\n')
        for e in cfg_ex:
            f_walk.write('- ' + e + '\n')
        for e in paths_lst_in:
            f_walk.write('+ ' + e + '\n')
        f_walk.write('- *\n')

        if f_walk:  # Offset file
            f_walk.seek(0)
        
        for srvname in cfg_hosts:  # Creating directory for each host
            try:
                final_path = d_dest + cfg_directory + srvname
            except:
                final_path = d_dest + srvname
            if not os.path.isdir(final_path):  # If local folder not exists, do it
                try:
                    vprint('Making directory', final_path)
                    mkpath(final_path)
                except Exception as e:
                    sys.exit('ERROR creating destination server directory: '+final_path+' - '+str(e))

            print '- Fetching:', srvname
            # Syncing files
            vprint('Calling: rsync', '-'+rsync_opt, '--progress', '--delete-excluded', '--timeout='+rsync_timeout, '--ignore-errors', '--max-size='+max_size, '--include-from=' + f_walk.name, '--prune-empty-dirs', rsync_user+'@'+srvname+':/', final_path)
            # For modify rsync call, the place is the following line (and the line above for verbose output):
            rsync_call = ('rsync', '-'+rsync_opt, '--progress', '--delete-excluded', '--timeout='+rsync_timeout, '--ignore-errors', '--max-size='+max_size, '--include-from=' + f_walk.name, '--prune-empty-dirs', rsync_user+'@'+srvname+':/', final_path)
            try:
                sys.stdout.flush()
                if options.silent:
                    if call_silent(rsync_call, d_dest) and host_mon:
                        hosts_bad.append(srvname)
                    elif host_mon:
                        hosts_ok.append(srvname)
                    else:
                        hosts_not_mon.append(srvname)
                else:
                    if call(rsync_call) and host_mon:
                        hosts_bad.append(srvname)
                    elif host_mon:
                        hosts_ok.append(srvname)
                    else:
                        hosts_not_mon.append(srvname)
                    print
                sys.stdout.flush()

            except Exception as e:
                sys.stdout.flush()
                sys.exit('ERROR executing rsync command: ' + str(e))

        f_walk.close()

        if options.verbose:
            vprint('WARNING temporary files note deleted in verbose mode')
        else:
            os.remove(f_tmp_walk)

    if d_post_get:
        process_folder(d_post_get)  # Execute post-get.d

    time_fetched = time.time() - fetch_time
    print '- Fetching done'
else:
    vprint('Avoid fetching files')

if commit and repo_name:
    commit_time = time.time()
    print '- Committing start'
    if not os.path.isdir(d_dest+'.git'):
        sys.exit('ERROR: '+str(d_dest)+' not have a repository\nMaybe you need to initialize it with \"keepconf -i\"')

    if d_pre_commit:
        process_folder(d_pre_commit)  # Execute pre-commit.d

    if options.message:
        message = options.message
    else:
        message = 'Keepconf commit at '+time.strftime('%H:%M:%S - %A/%B/%Y')
        if hosts_ok or hosts_bad or hosts_not_mon:
            message += '\nHosts ok: '+'['+ str(len(hosts_ok))+'] ' + ', '.join(hosts_ok)
            message += '\nHosts bad: '+'['+ str(len(hosts_bad))+'] ' + ', '.join(hosts_bad)
            message += '\nHosts not mon: '+'['+ str(len(hosts_not_mon))+'] ' + ', '.join(hosts_not_mon)

    if repo_name == 'local':
        print '- Committing into local repository'
        try:
            sys.stdout.flush()
            if options.xilent:
                call_silent(('git', 'add', d_dest+'*'), d_dest)
                call_silent(('git', 'commit', '-am', message), d_dest)
            else:
                call(('git', 'add', d_dest+'*'), cwd=d_dest)
                call(('git', 'commit', '-am', message), cwd=d_dest)
        except Exception as e:
            sys.stdout.flush()
            sys.exit('ERROR committing into local repository: ' + str(e))
    else:
        # print '- Updating remote repository' # For avoid problems
        # call(('git', 'pull'), cwd=d_dest)
        print '- Committing into remote repository'
        try:
            sys.stdout.flush()
            if options.xilent:
                call_silent(('git', 'add', '--all'), d_dest)
                call_silent(('git', 'commit', '-am', message), d_dest)
                call_silent(('git', 'push'), d_dest)
            else:
                call(('git', 'add', '--all'), cwd=d_dest)
                call(('git', 'commit', '-am', message), cwd=d_dest)
                call(('git', 'push'), cwd=d_dest)
        except Exception as e:
            sys.stdout.flush()
            sys.exit('ERROR committing into remote repository: ' + str(e))
    sys.stdout.flush()

    if d_post_commit:
        process_folder(d_post_commit)  # Execute pre-commit.d

    time_committed = time.time() - commit_time
    print '- Committing done'
else:
    vprint('Avoid committing changes')

if fetch or (commit and repo_name):
    print('- ')

if fetch:
    print('- Hosts rsync\'ed: ' +'['+ str(len(hosts_ok)) +'] '+ ', '.join(hosts_ok))
    print('- Hosts not rsync\'ed: ' +'['+ str(len(hosts_bad)) +'] '+ ', '.join(hosts_bad))
    print('- Hosts not monitorized: ' +'['+ str(len(hosts_not_mon)) +'] '+ ', '.join(hosts_not_mon))
    print('- Fetched in: %.2f seconds' % time_fetched)
if commit and repo_name:
    print('- Committed in: %.2f seconds' % time_committed)

total_time = time.time() - start_time
if fetch or commit:
    print('- Completed in: %.2f seconds' % total_time)

if f_monitor:
    vprint('Writing stats to monitor file ', f_monitor)
    try:
        if hosts_bad:
            hosts_bad_list = ","+ ','.join(['\"'+ x +'\"' for x in hosts_bad])
        else:
            hosts_bad_list = ''
        if hosts_ok:
            hosts_ok_list = "," +','.join(['\"'+ x +'\"' for x in hosts_ok])
        else:
            hosts_ok_list = ''
        if hosts_not_mon:
            hosts_not_mon_list = "," +','.join(['\"'+ x +'\"' for x in hosts_not_mon])
        else:
            hosts_not_mon_list = ''
        with open(f_monitor, "a") as file_monitor:
            try:
                file_monitor.write('\"KPCNF-OK\",\"' + str(len(hosts_ok)) + '\"' + hosts_ok_list + '\n')
            except:
                file_monitor.write('\"KPCNF-OK\",\"0\"\n')
            try:
                file_monitor.write('\"KPCNF-BAD\",\"' + str(len(hosts_bad)) + '\"' + hosts_bad_list + '\n')
            except:
                file_monitor.write('\"KPCNF-BAD\",\"0\"\n')
            try:
                file_monitor.write('\"KPCNF-NOT\",\"' + str(len(hosts_not_mon)) + '\"' + hosts_not_mon + '\n')
            except:
                file_monitor.write('\"KPCNF-NOT\",\"0\"\n')
            try:
                file_monitor.write('\"FETCH-TIME\",\"%.2f' % time_fetched + '\"\n')
            except:
                file_monitor.write('\"FETCH-TIME\",\"0\"\n')
            try:
                file_monitor.write('\"COMMIT-TIME\",\"%.2f' % time_committed + '\"\n')
            except:
                file_monitor.write('\"COMMIT-TIME\",\"0\"\n')
            file_monitor.write('\"TOTAL-TIME\",\"%.2f' % total_time + '\"\n')
    except Exception as e:
        sys.exit('ERROR writing into monitor file: ' + str(e))
